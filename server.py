from flask import Flask,request,render_template,send_file,jsonify,make_response
from flask_executor import Executor
from werkzeug.utils import secure_filename
import utility
import os,time
import curlExecutor
from massAssignment import MassAssignment
from brokenaccesscontrol import BACcurlextract
from Idor import IDORcurlextract
from AFupload import AFCode
from http_header_Injections import Attack_http

app = Flask(__name__)
executor = Executor(app)

# import server.routes
app.config['mainPath'] = os.getcwd()
app.config["tempUploads"] = os.path.join(app.config['mainPath'], "tempUploads")
app.config['Results'] = os.path.join(app.config['mainPath'],"Results")
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024

@app.route("/",methods=['GET',"POST"])
def landingPage():
	if request.form:
		print("Form : ",request.form)
	if request.files:
		print("Files : ",request.files)
	if request.json:
		print("JSON : ",request.json)
	return(f"<h1>CyberSec Landing Page</h1><br>")


@app.route("/startProcess",methods=['GET'])
def StartProcessGET():
	return render_template("index.html")


@app.route("/startProcess",methods=['POST'])
def fetchCurls():
	attackFlag=0
	curlFile = None
	XSS,XSSpayloads = False,None
	CSRF,CSRFpayloads = False,None
	SQL,SQLpayloads = False,None
	massAsg,maKeys,maValues = False,None,None
	BAC,BACpayloads=False,None
	IDOR,IDORpayloads=False,None
	HHI,HHIpayloads = False,None
	files = False
	
	if not request.form:
		return ( returnResponse(code=401, msg="No form data found", data=[]) )

	print("Form Data : ",request.form)
	if "curlFileTA" in request.form:
			curlFile = request.form['curlFileTA']
	if "XSSbox" in request.form:
		XSS=True
		if "xssFileTA" in request.form:
			XSSpayloads = request.form['xssFileTA']
	if "CSRFbox" in request.form:
		CSRF=True 
		if "csrfFileTA" in request.form:
			CSRFpayloads = request.form['csrfFileTA']
	if "SQLbox" in request.form:
		SQL = True 
		if "sqlFileTA" in request.form:
			SQLpayloads = request.form['sqlFileTA']
	if "massAsgBox" in request.form:
		massAsg = True
		if "maKeysTA" in request.form:
			maKeys = request.form['maKeysTA']
		if "maValuesTA" in request.form:
			maValues = request.form['maValuesTA']
	if "bacbox" in request.form:
		BAC = True 
		if "bacFileTA" in request.form:
			if request.form['bacFileTA']!= '':
				BACpayloads = request.form['bacFileTA']
	if "IDORBox" in request.form:
		IDOR = True
		if "idorfileTA" in request.form:
			IDORpayloads = request.form['idorfileTA']
	if "HHIbox" in request.form:
		HHI = True
		if "hhifileTA" in request.form:
			HHIpayloads = request.form["hhifileTA"]

	if curlFile == None:
		return(  utility.returnResponse( code=404, msg="curl Data not provided", data=[]) )
	if curlFile == "":
		return(  utility.returnResponse( code=404, msg="curl Data not provided", data=[]) )
	# print(str(curlFile))
	curlFileName = utility.makeUniqueFileName("curlFile_.txt")
	curlFileLoc = os.path.join(app.config['tempUploads'], curlFileName)
	
	with open(curlFileLoc, 'w') as f:
		f.write(str(curlFile))

	respArr=[]
	
	if XSS:
		if XSSpayloads==None:
			return(  utility.returnResponse( code=404, msg="Error processing XSS payload Data", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		elif len(XSSpayloads) == 0:
			return(  utility.returnResponse( code=404, msg="Error processing XSS payload Data", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		else:
			XSSAttackID = utility.reserveID()
			filename = utility.makeUniqueFileName("XSSpayloads_.txt", XSSAttackID)
			XSSpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
			with open(XSSpayloadsLoc, 'w') as f:
				f.write(str(XSSpayloads))
			outFileName = utility.makeUniqueFileName("report_", XSSAttackID)
			utility.linkID(XSSAttackID, outFileName)
			respArr.append( {"XSSAttackID":XSSAttackID} )
			attackFlag=1
			executor.submit(curlExecutor.Attack, curlFileLoc, outFileName, XSSpayloadsLoc, XSSAttackID)
			time.sleep(1)
	
	if CSRF:
		if CSRFpayloads==None:
			return( utility.returnResponse( code=404, msg="Error processing CSRF payload Data", data=respArr, toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		elif len(CSRFpayloads) == 0:
			return(  utility.returnResponse( code=404, msg="Error processing CSRF payload Data", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		else:
			CSRFAttackID = utility.reserveID()
			filename = utility.makeUniqueFileName("CSRFpayloads_.txt", CSRFAttackID)
			CSRFpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
			with open(CSRFpayloadsLoc, 'w') as f:
				f.write(str(CSRFpayloads))	
			outFileName = utility.makeUniqueFileName("report_", CSRFAttackID)
			utility.linkID(CSRFAttackID, outFileName)
			respArr.append( {"CSRFAttackID":CSRFAttackID} )
			attackFlag=1
			executor.submit(curlExecutor.Attack,curlFileLoc,outFileName,CSRFpayloadsLoc,CSRFAttackID)
			time.sleep(1)
	
	if SQL:
		if SQLpayloads==None:
			return( utility.returnResponse( code=404, msg="Error processing SQL payload Data", data=respArr,toBeDeleted=[curlFileLoc]) )
		elif len(SQLpayloads) == 0:
			return(  utility.returnResponse( code=404, msg="Error processing SQL payload Data", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		else:
			SQLAttackID = utility.reserveID()
			filename = utility.makeUniqueFileName("SQLpayloads_.txt", SQLAttackID)
			SQLpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
			with open(SQLpayloadsLoc, 'w') as f:
				f.write(str(SQLpayloads))
			outFileName = utility.makeUniqueFileName("report_", SQLAttackID)
			utility.linkID(SQLAttackID, outFileName)
			respArr.append( {"SQLAttackID":SQLAttackID} )
			attackFlag=1
			executor.submit(curlExecutor.Attack_http,curlFileLoc,outFileName,SQLpayloadsLoc,SQLAttackID)
			time.sleep(1)

	if massAsg:
		if maKeys == None or maValues == None:
			return( utility.returnResponse( code=404, msg="Keys or Values not provided", data=respArr, toBeDeleted=[curlFileLoc], attackFlag=attackFlag ) )
		elif len(maKeys) == 0 or len(maValues) ==0 :
			return(  utility.returnResponse( code=404, msg="Error processing Key Value Pair of mass assignment", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
		else:
			maAttackID = utility.reserveID()
			
			keyFilename = utility.makeUniqueFileName("maKey_.txt", maAttackID)
			valueFilename = utility.makeUniqueFileName("maValue_.txt", maAttackID)

			keyFileLoc = os.path.join(app.config['tempUploads'], keyFilename)
			valueFileLoc = os.path.join(app.config['tempUploads'], valueFilename)

			with open(keyFileLoc, 'w') as f:
				f.write(str(maKeys))
			with open(valueFileLoc, 'w') as f:
				f.write(str(maValues))
			
			outFileName = utility.makeUniqueFileName("report_", maAttackID)
			utility.linkID(maAttackID, outFileName)
			
			respArr.append( {"maAttackID":maAttackID} )
			attackFlag=1
			
			executor.submit(MassAssignment, curlFileLoc ,outFileName, maAttackID, keyFileLoc, valueFileLoc )
			time.sleep(1)
	
	if BAC:
		BACAttackID = utility.reserveID()
		filename = utility.makeUniqueFileName("BACpayloads_.txt", BACAttackID)
		BACpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
			
		with open(BACpayloadsLoc, 'w') as f:
			f.write(str(BACpayloads))
		outFileName = utility.makeUniqueFileName("report_", BACAttackID)
		utility.linkID(BACAttackID, outFileName) 
				
		respArr.append( {"BACAttackID":BACAttackID} )
		attackFlag=1
				
		executor.submit(BACcurlextract, curlFileLoc ,outFileName, BACAttackID ,BACpayloads )
		time.sleep(1)

	if IDOR:	
		IDORAttackID = utility.reserveID()
		filename = utility.makeUniqueFileName("IDORpayloads_.txt", IDORAttackID)
		IDORpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
		
		with open(IDORpayloadsLoc, 'w') as f:
				f.write(str(IDORpayloads))
		 
		outFileName = utility.makeUniqueFileName("report_", IDORAttackID)
		utility.linkID(IDORAttackID, outFileName)
			
		respArr.append( {"IDORAttackID":IDORAttackID} )
		attackFlag=1
			
		executor.submit(IDORcurlextract, curlFileLoc, IDORAttackID, outFileName, IDORpayloadsLoc )
		time.sleep(1)

	if HHI:	
		HHIAttackID = utility.reserveID()
		filename = utility.makeUniqueFileName("HHIpayloads_.txt", HHIAttackID)
		HHIpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
		
		with open(HHIpayloadsLoc, 'w') as f:
			f.write(str(HHIpayloads))
		 
		outFileName = utility.makeUniqueFileName("report_", HHIAttackID)
		utility.linkID(HHIAttackID, outFileName)
			
		respArr.append( {"HHIAttackID":HHIAttackID} )
		attackFlag=1
			
		executor.submit(Attack_http, curlFileLoc, HHIAttackID, outFileName, HHIpayloadsLoc )
		time.sleep(1)


		

	if attackFlag == 0:
		return( utility.returnResponse(  code=400, msg="Attack could not be performed as no attack type was selected", data=respArr, toBeDeleted=[curlFileLoc], attackFlag=attackFlag ) )
	return( utility.returnResponse(  code=200, msg="Attack Started", data=respArr ) )


@app.route("/results/<AttackID>")
def profile(AttackID):
	if utility.isInvalidAttackID(AttackID):
		return(  utility.returnResponse(  code=401, msg="Invalid AttackID format", data=[] ) )
	print("current AttacksIDs : ",utility.AttackIDs)
	# for P_id  in AttackIDs:
	if AttackID in utility.AttackIDs:
		P_status = utility.AttackIDs[AttackID][0]
		file_name = utility.AttackIDs[AttackID][1]
		
		if P_status == 200:
			if utility.isTooLarge(file_name+".json"):
				return( utility.returnResponse(  code=400, msg="File size is too large to send", data=[]) )
			if os.path.isfile(os.path.join( app.config['Results'], file_name+".json")):
				return send_file( os.path.join( app.config['Results'], file_name+".json") ), 200
			else:
				return( utility.make_response( code=400, msg="File not found (file ight contain some errors)", data=[] ) )
		elif P_status == 300:
			return send_file( os.path.join( app.config['Results'], file_name+".json") ), 300
	else:
		return( utility.returnResponse(  code=404, msg="Process not found", data=[]) )


@app.route("/AF",methods=['GET'])
def AF_GET():
	return render_template("AFindex.html")


@app.route("/AF",methods=['POST'])
def AF_POST():
	attackFlag=0
	curlFile = None
	files=False
	AFAttackID = None
	AFpayloads = None

	if not request.form:
		return ( returnResponse(code=401, msg="No form data found", data=[]) )

	if "AFAttackID" in request.headers :
		AFAttackID = request.headers['AFAttackID']
		if utility.isInvalidAttackID(AFAttackID):
			return(  utility.returnResponse(  code=401, msg="Invalid AttackID format", data=[] ) )
	else:
		AFAttackID = utility.reserveID()

	print("Form Data : ",request.form)
	if "curlFileTA" in request.form:
			curlFile = request.form['curlFileTA']

	if "AFfileTA" in request.form:
		AFpayloads = request.form['AFfileTA']

	if "AFfile" in request.files:
		AFpayloads = request.files["AFfile"]

	if curlFile == None:
		return(  utility.returnResponse( code=404, msg="curl Data not provided", data=[]) )
	if curlFile == "":
		return(  utility.returnResponse( code=404, msg="curl Data not provided", data=[]) )

	respArr=[]
	curlFileName = utility.makeUniqueFileName("curlFile_.txt")
	curlFileLoc = os.path.join(app.config['tempUploads'], curlFileName)

	with open(curlFileLoc, 'w') as f:
		f.write(str(curlFile))

	if AFpayloads==None:
		return(  utility.returnResponse( code=404, msg="Error processing AF payload Data", data=[], toBeDeleted=[curlFileLoc], attackFlag=attackFlag) )
	else:
		filename = utility.makeUniqueFileName("AFpayloads_.json", AFAttackID)
		AFpayloadsLoc = os.path.join(app.config['tempUploads'], filename)
		# AFpayloads.save( AFpayloadsLoc )
		with open(AFpayloadsLoc, 'w') as f:
			f.write(str(AFpayloads))
		AFpayloads.save( os.path.join(app.config['tempUploads'], filename) )
		outFileName = utility.makeUniqueFileName("report_", AFAttackID)
		utility.linkID(AFAttackID, outFileName)
		# IdString += "   AFAttackID = " + AFAttackID
		respArr.append( {"AFAttackID":AFAttackID} )
	
	status = AFCode(curlFileLoc,AFAttackID,AFpayloadsLoc,outFileName)
	if status == False:
		return( utility.returnResponse( code=401, msg="Error occured while executing Command", data=[] ) )

	print("current AttacksIDs : ",utility.AttackIDs,status)
	# for P_id  in AttackIDs:
	if AFAttackID in utility.AttackIDs:
		P_status = utility.AttackIDs[AFAttackID][0]
		file_name = utility.AttackIDs[AFAttackID][1]
		print(P_status,file_name)
		if P_status == 200:
			if utility.isTooLarge(file_name+".json"):
				return( utility.returnResponse(  code=400, msg="File size is too large to send", data=[]) )
			return send_file( os.path.join( app.config['Results'], file_name+".json") ), 200
		elif P_status == 300:
			return send_file( os.path.join( app.config['Results'], file_name+".json") ), 300
	else:
		return( utility.returnResponse(  code=404, msg="Process not found", data=[]) )




if __name__ == "__main__":
	app.run(debug=True,port=5000,host="0.0.0.0")


# check headers and if it affects the input/file upload
# JSON inside JSON
# if all threads are used then store the video for future processing in a folder
